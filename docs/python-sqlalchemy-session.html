<!DOCTYPE html>

<html>





<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <title>SQLAlchemy의 세션 관리 - miintto.log</title>

  <meta name="description" content="보통 Django를 벗어나서 독자적인 ORM이 없는 파이썬 프레임워크를 사용한다면 아마 거의 대부분은 SQLAlchemy를 채택하여 사용할 겁니다. 최근 FastAPI를 이용해 개발하면서 SQLAlchemy를 다루어 보았는데, 해당 라이브러리에서 DB 세션을 어떻게 관리하는지 정리...">

  <meta name="google-site-verification" content="wGN_mZVjgAC8sdItYCBTkSMwLrgNSWPY6sicU3MuSQw" />

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lora:ital@1&display=swap">
  <link rel="stylesheet" as="style" crossorigin href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.9/dist/web/static/pretendard.min.css" />

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://miintto.github.io/docs/python-sqlalchemy-session">
  <link rel="alternate" type="application/rss+xml" title="SQLAlchemy의 세션 관리 - miintto.log" href="/feed.xml">

  <link rel="apple-touch-icon" href="/img/favicon-128.png">
  <link rel="shortcut icon" type="image/x-icon" href="/img/favicon.ico">
  <link rel="icon" type="image/x-icon" href="/img/favicon.ico">

  <meta prefix="og: http://ogp.me/ns#" property="og:site_name" content="miintto.log"/>
  <meta prefix="og: http://ogp.me/ns#" property="og:type" content="blog"/>
  <meta prefix="og: http://ogp.me/ns#" property="og:title" content="SQLAlchemy의 세션 관리 - miintto.log"/>
  <meta prefix="og: http://ogp.me/ns#" property="og:description" content="보통 Django를 벗어나서 독자적인 ORM이 없는 파이썬 프레임워크를 사용한다면 아마 거의 대부분은 SQLAlchemy를 채택하여 사용할 겁니다. 최근 FastAPI를 이용해 개발하면서 SQLAlchemy를 다루어 보았는데, 해당 라이브러리에서 DB 세션을 어떻게 관리하는지 정리..."/>
  <meta prefix="og: http://ogp.me/ns#" property="og:locale" content="ko_KR"/>
  <meta prefix="og: http://ogp.me/ns#" property="og:url" content="https://miintto.github.io/docs/python-sqlalchemy-session"/>
  <meta prefix="og: http://ogp.me/ns#" property="og:image" content="/img/thumbnails/sqlalchemy.png">

</head>


<body>

  <!-- Navigation -->

<nav class="navbar" style="background-color: white;">

  <div class="navbar-content container">
    <a class="navbar-brand" href="/">miintto.log</a>
    <button class="navbar-button" id="toggleButton" type="button" data-toggle="collapse" aria-controls="navbarResponsive" aria-expanded="false">
      MENU
      <i class="fa fa-bars"></i>
    </button>
    <div class="navbar-nav" id="navbarResponsive" aria-hidden="true">
      <div class="nav-item">
        <a class="nav-link" href="/about">ABOUT</a>
      </div>
      <div class="nav-item">
        <a class="nav-link" href="/posts">POSTS</a>
      </div>
      <div class="nav-item">
        <a class="nav-link" href="/archive">ARCHIVES</a>
      </div>
    </div>
  </div>
</nav>


  <div class="article">
  <div class="article-wrapper">
    <div class="article-header">
      <div class="article-info">
        <h1>SQLAlchemy의 세션 관리</h1>
        <div class="post-tags">
          <p>python</p><p>sqlalchemy</p><p>session</p><p>orm</p><p>thread-local</p>
        </div>
        <div class="article-meta">
          2023.01.03 &middot; <span class="reading-time" title="Estimated read time">
  
   13 mins  read </span>

        </div>
      </div>
      <div class="article-banner"">
        <img src="/img/thumbnails/sqlalchemy.png">
      </div>
    </div>

    <div class="article-content">
      <aside>
  <div class="section-toc">
  </div>
</aside>


      <p>보통 Django를 벗어나서 독자적인 ORM이 없는 파이썬 프레임워크를 사용한다면 아마 거의 대부분은 SQLAlchemy를 채택하여 사용할 겁니다.
최근 FastAPI를 이용해 개발하면서 SQLAlchemy를 다루어 보았는데,
해당 라이브러리에서 DB 세션을 어떻게 관리하는지 정리해 보았습니다.</p>

<hr />

<h1 id="1-session">1. Session</h1>

<p>일반적으로 <strong>세션</strong>(session)이란 데이터베이스와 클라이언트 사이에서 통신을 시작하는 것부터 종료하기까지의 수명 기간을 의미합니다.
그리고 SQLAlchemy 라이브러리에서 이 세션의 구현체가 바로 <code class="language-plaintext highlighter-rouge">sqlalchemy.orm.Session</code> 클래스입니다.</p>

<p><code class="language-plaintext highlighter-rouge">Session</code>은 identity map이라고 불리는 내부 공간에 ORM 객체들을 저장하며, 변경이 일어날 때마다 그 이력이 기록됩니다.
최초 쿼리 작업을 요청하거나 관련된 객체를 건드리는 순간 Session은 새로운 <strong>트랜잭션</strong>(transaction)을 생성하는데, 해당 트랜잭션은 세션이 커밋되거나 롤백 되기 전까지 유지됩니다.
그리고 해당 트랜잭션이 커밋되면 모든 변경 사항들을 데이터베이스로 전송합니다.</p>

<p>아래 코드는 <code class="language-plaintext highlighter-rouge">Session</code>을 이용하여 새 데이터를 생성하는 간단한 예시입니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">sqlalchemy</span> <span class="kn">import</span> <span class="n">create_engine</span>
<span class="kn">from</span> <span class="n">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">Session</span>

<span class="n">engine</span> <span class="o">=</span> <span class="nf">create_engine</span><span class="p">(</span><span class="n">url</span><span class="o">=</span><span class="sh">"</span><span class="s">postgresql://user:password@localhost:5432/test_db</span><span class="sh">"</span><span class="p">)</span>

<span class="k">with</span> <span class="nc">Session</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
    <span class="n">user</span> <span class="o">=</span> <span class="nc">User</span><span class="p">(</span><span class="n">user_name</span><span class="o">=</span><span class="sh">"</span><span class="s">myname</span><span class="sh">"</span><span class="p">,</span> <span class="n">email</span><span class="o">=</span><span class="sh">"</span><span class="s">miintto.log@gmail.com</span><span class="sh">"</span><span class="p">)</span>
    <span class="n">session</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
    <span class="n">session</span><span class="p">.</span><span class="nf">commit</span><span class="p">()</span>
    <span class="c1"># BEGIN (implicit)
</span>    <span class="c1"># INSERT INTO user (username, email) VALUES ('myname', 'miintto.log@gmail.com');
</span>    <span class="c1"># COMMIT
</span></code></pre></div></div>

<h2 id="11-add">1.1 add</h2>

<p><code class="language-plaintext highlighter-rouge">Session.add()</code> 메소드는 세션 내에 객체들을 배치하는 역할을 합니다.
<strong>비영속</strong>(transient) 객체, 즉 새로 생성되어 아직 데이터베이스 정보가 없는 객체들은 flush 되는 시점에 INSERT 작업이 수행됩니다.
기존에 세션이 가져왔던 <strong>영속</strong>(persistant) 객체들은 이미 세션 내에 배치되어 있는 상태라 굳이 add 작업을 할 필요가 없습니다.
<strong>준영속</strong>(detached) 객체는 세션과 한 번 연결되었다가 분리된 객체인데 <code class="language-plaintext highlighter-rouge">add()</code> 메소드를 사용하여 다시 연결할 수 있습니다.</p>

<h2 id="12-flush">1.2 flush</h2>

<p>flush가 실행되면 트랜잭션에 있는 변동 내역이 DB에 전송됩니다.
해당 내역은 INSERT, UPDATE, DELETE 같은 내용을 담고 있으나 아직 DB에 반영되지 않은 대기 상태로 존재합니다.</p>

<p>수기로 <code class="language-plaintext highlighter-rouge">Session.flush()</code>를 호출하여 실행할 수 있지만, 기본적으로 <code class="language-plaintext highlighter-rouge">autoflush=True</code>로 설정되어 있어서 작업 도중 자동으로 flush가 실행됩니다.
공식 문서에 따르면 다음 조건 하에서 autoflush가 작동합니다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Session.execute()</code>를 포함한 SQL 실행 메소드 호출 시</li>
  <li>SQL을 데이터베이스로 전송하기 위해 <code class="language-plaintext highlighter-rouge">Query</code>를 작동시키는 경우</li>
  <li>데이터베이스에 쿼리를 날리기 전에 <code class="language-plaintext highlighter-rouge">Session.merge()</code> 메소드 내부에서 작동</li>
  <li>객체를 refresh 하는 경우</li>
  <li>아직 데이터를 호출하지 않은 객체에서 ORM lazy-loading이 발생하는 경우</li>
</ul>

<p>또한 <code class="language-plaintext highlighter-rouge">autoflush</code> 값과 무관하게 <code class="language-plaintext highlighter-rouge">Session.commit()</code>메소드 내부 트랜잭션 커밋 전에 작동하며,
<code class="language-plaintext highlighter-rouge">Session.begin_nested()</code> 호출 시 SAVEPOINT를 생성하기 전에도 반드시 flush가 작동합니다.</p>

<h2 id="13-commit">1.3 commit</h2>

<p><code class="language-plaintext highlighter-rouge">Session.commit()</code> 메소드는 변동된 내용을 flush 하고 현재 트랜잭션을 커밋합니다.
해당 메소드는 다음 순서대로 작동합니다.</p>

<ol>
  <li>COMMIT을 날리기 전에 변동된 내용을 flush 합니다. 
만일 변동된 내용이 없다면 아무 쿼리도 실행되지 않습니다.</li>
  <li>데이터베이스 트랜잭션을 COMMIT 합니다.</li>
  <li>트랜잭션이 종료되면 세션 내에 배치되었던 모든 객체들은 정리됩니다.</li>
</ol>

<p>세션에 영속된 객체에 대한 작업을 종료한 후 커밋은 필수적이지만, SELECT 작업같이 특정한 변화를 주지 않는 단순 조회시에는 굳이 커밋이 필요 없습니다.</p>

<p>아래와 같이 <code class="language-plaintext highlighter-rouge">with session.begin()</code> 구문을 이용하면 context가 끝나는 시점에 자동으로 커밋되도록 할 수도 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">with</span> <span class="nc">Session</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">session</span><span class="p">.</span><span class="nf">begin</span><span class="p">():</span>
        <span class="n">user</span> <span class="o">=</span> <span class="nc">User</span><span class="p">(</span><span class="n">user_name</span><span class="o">=</span><span class="sh">"</span><span class="s">myname</span><span class="sh">"</span><span class="p">,</span> <span class="n">email</span><span class="o">=</span><span class="sh">"</span><span class="s">miintto.log@gmail.com</span><span class="sh">"</span><span class="p">)</span>
        <span class="n">session</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
    <span class="c1"># with 구문 끝날때 session.commit() 실행
# with 구문 끝날때 session.close() 실행
</span></code></pre></div></div>

<h2 id="14-close">1.4 close</h2>

<p><code class="language-plaintext highlighter-rouge">Session.close()</code> 메소드는 세션에 배치되었던 모든 ORM 객체를 제거하고 트랜잭션 및 커넥션 자원을 다시 반납합니다.
커넥션이 커넥션 풀로 반납되면 트랜잭션 상태도 다시 롤백 됩니다.
세션은 종료되고 나면 처음 생성되었을 때의 구성과 동일한 상태로 돌아가서 대부분은 다시 재사용 됩니다.</p>

<p>어떻게 보면 세션의 close 작업은 <em>“종료”</em> 보다는 <em>“리셋”</em> 에 더 가깝습니다.
따라서 롤백이나 커밋 작업을 수행하지 않았더라도 세션의 범위를 제한하기 위해 수행할 작업을 마친 후 <code class="language-plaintext highlighter-rouge">close()</code> 메소드 호출이 권장됩니다.
다행히도 <code class="language-plaintext highlighter-rouge">Session.__exit__()</code> 메소드 내부에 세션을 close 하는 부분이 구현되어 있으므로 <code class="language-plaintext highlighter-rouge">with Session()</code> 구문을 활용한다면 context가 끝나는 시점에 자동으로 <code class="language-plaintext highlighter-rouge">Session.close()</code>가 호출되도록 프로그래밍할 수 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Session</span><span class="p">(</span><span class="n">_SessionClassMethods</span><span class="p">):</span>
    <span class="bp">...</span>
    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span>

    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">type_</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">traceback</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>
</code></pre></div></div>

<hr />

<h1 id="2-sessionmaker">2. <code class="language-plaintext highlighter-rouge">sessionmaker</code></h1>

<p>만일 고정된 환경 구성으로 세션을 생성하려는 경우 <code class="language-plaintext highlighter-rouge">sessionmaker</code>를 활용하면 좋습니다.
마치 동일한 구성을 가진 세션을 찍어내는 factory 기능을 합니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">sessionmaker</span><span class="p">(</span><span class="n">_SessionClassMethods</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">A configurable :class:`.Session` factory.</span><span class="sh">"""</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span>
        <span class="n">self</span><span class="p">,</span>
        <span class="n">bind</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
        <span class="n">class_</span><span class="o">=</span><span class="n">Session</span><span class="p">,</span>
        <span class="n">autoflush</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
        <span class="n">autocommit</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
        <span class="n">expire_on_commit</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
        <span class="n">info</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kw</span>
    <span class="p">):</span>
        <span class="n">kw</span><span class="p">[</span><span class="sh">"</span><span class="s">bind</span><span class="sh">"</span><span class="p">]</span> <span class="o">=</span> <span class="n">bind</span>
        <span class="n">kw</span><span class="p">[</span><span class="sh">"</span><span class="s">autoflush</span><span class="sh">"</span><span class="p">]</span> <span class="o">=</span> <span class="n">autoflush</span>
        <span class="n">kw</span><span class="p">[</span><span class="sh">"</span><span class="s">autocommit</span><span class="sh">"</span><span class="p">]</span> <span class="o">=</span> <span class="n">autocommit</span>
        <span class="n">kw</span><span class="p">[</span><span class="sh">"</span><span class="s">expire_on_commit</span><span class="sh">"</span><span class="p">]</span> <span class="o">=</span> <span class="n">expire_on_commit</span>
        <span class="k">if</span> <span class="n">info</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">kw</span><span class="p">[</span><span class="sh">"</span><span class="s">info</span><span class="sh">"</span><span class="p">]</span> <span class="o">=</span> <span class="n">info</span>
        <span class="n">self</span><span class="p">.</span><span class="n">kw</span> <span class="o">=</span> <span class="n">kw</span>
        <span class="n">self</span><span class="p">.</span><span class="n">class_</span> <span class="o">=</span> <span class="nf">type</span><span class="p">(</span><span class="n">class_</span><span class="p">.</span><span class="n">__name__</span><span class="p">,</span> <span class="p">(</span><span class="n">class_</span><span class="p">,),</span> <span class="p">{})</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="o">**</span><span class="n">local_kw</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">kw</span><span class="p">.</span><span class="nf">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="sh">"</span><span class="s">info</span><span class="sh">"</span> <span class="ow">and</span> <span class="sh">"</span><span class="s">info</span><span class="sh">"</span> <span class="ow">in</span> <span class="n">local_kw</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="nf">copy</span><span class="p">()</span>
                <span class="n">d</span><span class="p">.</span><span class="nf">update</span><span class="p">(</span><span class="n">local_kw</span><span class="p">[</span><span class="sh">"</span><span class="s">info</span><span class="sh">"</span><span class="p">])</span>
                <span class="n">local_kw</span><span class="p">[</span><span class="sh">"</span><span class="s">info</span><span class="sh">"</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">local_kw</span><span class="p">.</span><span class="nf">setdefault</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">class_</span><span class="p">(</span><span class="o">**</span><span class="n">local_kw</span><span class="p">)</span>   <span class="c1"># 세션 객체 반환: Session(**local_kw)
</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">sessionmaker.__call__()</code> 메소드의 결과로 주어진 engine 설정에 부합하는 <code class="language-plaintext highlighter-rouge">Session</code> 객체를 반환합니다.
해당 기능을 사용하면 매번 DB 연결 정보가 담겨있는 engine 객체로 <code class="language-plaintext highlighter-rouge">Session</code>을 생성할 필요 없이 글로벌한 위치에서 세션을 정의하고 다른 모듈에서는 해당 세션을 import 하여 사용하는 방식으로 구성할 수 있습니다. 
주로 어플리케이션같이 여러 모듈에서 세션을 반복적으로 사용하는 경우에 활용할 수 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># config.py
</span><span class="kn">from</span> <span class="n">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">sessionmaker</span>

<span class="n">engine</span> <span class="o">=</span> <span class="nf">create_engine</span><span class="p">(</span><span class="n">url</span><span class="o">=</span><span class="sh">"</span><span class="s">postgresql://user:password@localhost:5432/test_db</span><span class="sh">"</span><span class="p">)</span>
<span class="n">Session</span> <span class="o">=</span> <span class="nf">sessionmaker</span><span class="p">(</span><span class="n">bind</span><span class="o">=</span><span class="n">engine</span><span class="p">)</span>


<span class="c1"># module.py
</span><span class="kn">from</span> <span class="n">my_module.config</span> <span class="kn">import</span> <span class="n">Session</span>

<span class="k">with</span> <span class="nc">Session</span><span class="p">()</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
    <span class="n">session</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">some_object</span><span class="p">)</span>
    <span class="n">session</span><span class="p">.</span><span class="nf">commit</span><span class="p">()</span>

<span class="k">with</span> <span class="n">Session</span><span class="p">.</span><span class="nf">begin</span><span class="p">()</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
    <span class="n">session</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">some_object</span><span class="p">)</span>
<span class="c1"># commit session
</span></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Session.begin()</code>과 동일하게 <code class="language-plaintext highlighter-rouge">sessionmaker.begin()</code> 메소드도 context 가 끝날 때 자동으로 커밋작업을 수행합니다.</p>

<hr />

<h1 id="3-scoped_session">3. <code class="language-plaintext highlighter-rouge">scoped_session</code></h1>

<p>웹 어플리케이션을 개발하다보면 어떤 부분에서 세션을 생성하여 어디서 종료하는지와 같은 세션의 생명 주기를 매 request마다 관리해 주어야 합니다.
같은 모듈 내의 작업도 request에 따라 별개로 처리하고, 동일한 request에서는 같은 세션을 사용하도록 하는 등 여러 가지 고려할 사항이 많습니다.
<code class="language-plaintext highlighter-rouge">scoped_session</code>는 그러한 요구에 맞추어 요청한 클라이언트에 따라 세션을 고정시키는 역할을 합니다.</p>

<h2 id="31-usage-of-scoped_session">3.1 Usage of <code class="language-plaintext highlighter-rouge">scoped_session</code></h2>

<p>일반적으로 <code class="language-plaintext highlighter-rouge">Session</code> 혹은 <code class="language-plaintext highlighter-rouge">sessionmaker</code>는 독립적인 세션 객체를 만들어냅니다.
아래와 같이 동일한 모듈에서 생성하더라도 생성된 <code class="language-plaintext highlighter-rouge">Session</code> 객체들은 서로 다른 객체인 것을 확인할 수 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">Session</span>

<span class="n">session1</span> <span class="o">=</span> <span class="nc">Session</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span>
<span class="n">session2</span> <span class="o">=</span> <span class="nc">Session</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span>
<span class="n">session1</span> <span class="ow">is</span> <span class="n">session2</span>
<span class="c1"># False
</span></code></pre></div></div>

<p>따라서 각 모듈마다 제각각 세션을 생성한다면 모듈 간의 데이터 공유도 까다로워지고 관리할 세션도 늘어나서 비효율적으로 작동하게 됩니다.
하지만 <code class="language-plaintext highlighter-rouge">scoped_session</code>를 사용하다면 해당 세션이 작업을 마칠 때까지 동일한 세션 객체를 반환하도록 할 수 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">sqlalchemy</span> <span class="kn">import</span> <span class="n">create_engine</span>
<span class="kn">from</span> <span class="n">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">scoped_session</span><span class="p">,</span> <span class="n">sessionmaker</span>

<span class="n">engine</span> <span class="o">=</span> <span class="nf">create_engine</span><span class="p">(</span><span class="n">url</span><span class="o">=</span><span class="sh">"</span><span class="s">postgresql://user:password@localhost:5432/test_db</span><span class="sh">"</span><span class="p">)</span>
<span class="n">session_factory</span> <span class="o">=</span> <span class="nf">sessionmaker</span><span class="p">(</span><span class="n">bind</span><span class="o">=</span><span class="n">engine</span><span class="p">,</span> <span class="n">autocommit</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">autoflush</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="n">Session</span> <span class="o">=</span> <span class="nf">scoped_session</span><span class="p">(</span><span class="n">session_factory</span><span class="o">=</span><span class="n">session_factory</span><span class="p">)</span>

<span class="n">session1</span> <span class="o">=</span> <span class="nc">Session</span><span class="p">()</span>
<span class="n">session2</span> <span class="o">=</span> <span class="nc">Session</span><span class="p">()</span>
<span class="n">session1</span> <span class="ow">is</span> <span class="n">session2</span>
<span class="c1"># True
</span></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">scoped_session</code> 클래스는 <code class="language-plaintext highlighter-rouge">__call__</code> 메소드의 결과값으로 <code class="language-plaintext highlighter-rouge">Session</code> 객체를 반환합니다.
이때 반환된 객체는 바로 전에 생성하였던 세션 객체와 동일한 객체입니다.
이렇게 <code class="language-plaintext highlighter-rouge">scoped_session</code>이 클라이언트를 기억할 수 있는 이유는 생성된 세션을 내부 저장소(registry)에 저장하고 요청한 클라이언트에 알맞은 세션을 반환하기 때문입니다.</p>

<h2 id="32-registry">3.2 Registry</h2>

<p><code class="language-plaintext highlighter-rouge">scoped_session</code> 클래스는 세션을 저장할 때 두 가지 형태의 registry를 사용하는데,
기본적으로 사용하는 <strong><code class="language-plaintext highlighter-rouge">ThreadLocalRegistry</code></strong>와 별도 <code class="language-plaintext highlighter-rouge">scopefunc</code>를 입력받은 경우 사용하는 <strong><code class="language-plaintext highlighter-rouge">ScopedRegistry</code></strong>가 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">scoped_session</span><span class="p">(</span><span class="n">ScopedSessionMixin</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">Provides scoped management of :class:`.Session` objects.</span><span class="sh">"""</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">session_factory</span><span class="p">,</span> <span class="n">scopefunc</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">session_factory</span> <span class="o">=</span> <span class="n">session_factory</span>
        <span class="k">if</span> <span class="n">scopefunc</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">registry</span> <span class="o">=</span> <span class="nc">ScopedRegistry</span><span class="p">(</span><span class="n">session_factory</span><span class="p">,</span> <span class="n">scopefunc</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">registry</span> <span class="o">=</span> <span class="nc">ThreadLocalRegistry</span><span class="p">(</span><span class="n">session_factory</span><span class="p">)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">scopefunc</code>는 세션의 범위를 구분할 메소드입니다.
해당 메소드는 반드시 해시 가능한 값을 반환해야 하는데, 그 해시값으로 클라이언트를 구분합니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ScopedRegistry</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">A Registry that can store one or multiple instances of a single
    class on the basis of a </span><span class="sh">"</span><span class="s">scope</span><span class="sh">"</span><span class="s"> function.
    </span><span class="sh">"""</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">createfunc</span><span class="p">,</span> <span class="n">scopefunc</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">createfunc</span> <span class="o">=</span> <span class="n">createfunc</span>
        <span class="n">self</span><span class="p">.</span><span class="n">scopefunc</span> <span class="o">=</span> <span class="n">scopefunc</span>
        <span class="n">self</span><span class="p">.</span><span class="n">registry</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">scopefunc</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">registry</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">except</span> <span class="nb">KeyError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">registry</span><span class="p">.</span><span class="nf">setdefault</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="nf">createfunc</span><span class="p">())</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">ScopedRegistry.registry</code>는 파이썬 dictionary 객체로 구성되어 있으며 해시값을 key로 세션 객체가 저장됩니다.
이러한 구조로 동시에 여러 세션 객체를 관리할 수 있고 클라이언트에 따라 적절한 세션을 반환하게 됩니다.
별다른 <code class="language-plaintext highlighter-rouge">scopefunc</code>를 정의하지 않으면 <code class="language-plaintext highlighter-rouge">threading.local()</code>을 사용하여 스레드 단위로 세션이 관리됩니다.</p>

<p>만일 세션을 끝내고 새로운 트랜잭션을 시작하고 싶다면 <code class="language-plaintext highlighter-rouge">scoped_session.remove()</code>를 호출하면 됩니다.
해당 메소드가 호출되면 세션의 <code class="language-plaintext highlighter-rouge">Session.close()</code> 작업으로 트랜잭션이 종료된 후, registry에서 해당 세션 객체가 제거됩니다.</p>

<h2 id="33-thread-local">3.3 Thread-Local</h2>

<p>기본적으로 <code class="language-plaintext highlighter-rouge">threading.local()</code>을 사용하는 이유는 바로 멀티스레딩 이슈 때문입니다.
보통 어플리케이션을 만들다 보면 멀티스레딩을 활용한 성능 향상을 고려하게 되는데, 이러한 환경에서도 스레드마다 독립적인 세션이 보장되어야 합니다.
따라서 각 스레드별 구분된 thread-local storage에 세션을 저장하여 여러 스레드마다 세션이 충돌 나지 않게 됩니다.</p>

<p>다만 동시성을 위해 greenlet, asyncio같은 라이브러리를 사용하는 환경에서는 race condition이 발생할 수 있습니다.
사실 필자가 SQLAlchemy를 학습한 이유가 FastAPI 환경에서 사용하기 위한 목적이었으나 정작 async 환경에서 적용하기에는 여러 위험 요소가 많았습니다.
다행스럽게도 2020년 11월에 1.4 버전이 릴리즈되면서 <code class="language-plaintext highlighter-rouge">AsyncSession</code>기능이 탑재되었는데 해당 기능에 대해서는 <a href="/docs/python-sqlalchemy-asyncsession">별도 포스트</a>에서 설명하겠습니다.</p>

<hr />

<p>References</p>

<ul>
  <li><a href="https://docs.sqlalchemy.org/en/14/orm/session.html">Using the Session - SQLAlchemy 1.4 Documents</a></li>
</ul>


      <hr>

      <div id="disqus_thread"></div>
      <script>
          (function() {
          var d = document, s = d.createElement('script');
          s.src = 'https://miintto-github-io.disqus.com/embed.js';
          s.setAttribute('data-timestamp', +new Date());
          (d.head || d.body).appendChild(s);
          })();
      </script>
      <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

      <hr>

    </div>
  </div>
</div>


  <!-- Footer -->

<hr>

<footer>
  <div class="footer-content container">
    <p class="copyright text-muted">Copyright &copy; miintto 2024</p>
  </div>
</footer>


  <script src="https://use.fontawesome.com/releases/v5.15.3/js/all.js" crossorigin="anonymous"></script>
<script src="/assets/scripts.js"></script>


  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-XXXXXXXXX-X"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-XXXXXXXXX-X');
</script>



</body>

</html>
